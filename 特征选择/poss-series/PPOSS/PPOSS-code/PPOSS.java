


	import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Map.Entry;
import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

	import org.ujmp.core.DenseMatrix;
import org.ujmp.core.Matrix;
import org.ujmp.core.calculation.Calculation.Ret;

	/**
	 * C. Qian, J.-C. Shi, Y. Yu, K. Tang and Z.-H. Zhou. Parallel Pareto Optimization for Subset Selection. In: Proceedings of the 25th International Joint Conference on Artificial Intelligence (IJCAI'16), New York, NY, 2016.
	 
	 * usage : to use this file, you need to change some variables in main function and you can also change the objective function in line 338 if needed.
	 */

	public class PPOSS {
		static List <Matrix> population = null; 
		static List <Matrix> fitness = null;	
		
		static String dataName;
		static Matrix X;
		static Matrix y;
	
		static int k = 8; 
		
		static long m, n; //column and row
		static Random rand = new Random();
		static Matrix probabilityTable = DenseMatrix.Factory.zeros(2, 2);
		
		static long T; 
		static int popSize;
		
		//static String resultFileName = null;
		
		static Matrix [] offspringFits; 
		static Matrix [] offsprings;	
		static volatile Matrix offspringChosen = null; //all sub-threads use the same solution to mutation
		static volatile boolean [] isNewSolutionProducted; //whether a new solution is generated by some sub-thread
		static volatile boolean [] canNewSolutionAdapted;  //whether the solution generated by sub-thread can be accepted by main thread
		static ArrayList <ArrayList <Integer> > indexOfSolutionToRetain = new ArrayList < ArrayList <Integer> >(); 
		
		static int evalNumToShow = 1000; 
		
		public static Matrix POSS_Multi_Thread(int numOfThreads) {
			System.out.println("core : " + numOfThreads);
			double t = System.currentTimeMillis();
			
			for (int i = 0; i < numOfThreads; i ++) { 
				indexOfSolutionToRetain.add(new ArrayList<Integer>());
			}
			
			population = new LinkedList<Matrix>();
			fitness = new LinkedList<Matrix>();
			population.add(DenseMatrix.Factory.zeros(1,n));
			Matrix ft = DenseMatrix.Factory.zeros(1, 2);
			ft.setAsDouble(Double.MAX_VALUE, 0, 0);
			fitness.add(ft);
			popSize = 1;
			offspringChosen = DenseMatrix.Factory.zeros(1,n);
			
			ExecutorService executor = Executors.newFixedThreadPool(numOfThreads);
			 
			offsprings = new Matrix[numOfThreads];
			offspringFits = new Matrix[numOfThreads];
			isNewSolutionProducted = new boolean[numOfThreads];
			canNewSolutionAdapted = new boolean[numOfThreads];
			
			ProductSolution [] productSolution = new ProductSolution[numOfThreads];
			for (int i = 0; i < numOfThreads; i ++) {
				productSolution[i] = new ProductSolution(i, (int)T / numOfThreads);
			}
			
			for (int i = 0; i < numOfThreads; i ++) {
				isNewSolutionProducted[i] = false;
			}
			
			for (int i = 0; i < numOfThreads; i ++) {
				executor.execute(productSolution[i]);
			}
			int index = 0;
			
			int stepToRecord =  evalNumToShow / numOfThreads ;
			
			outer : while (index < T / numOfThreads) {
				for (int j = 0; j < numOfThreads; j ++) {
					if (!isNewSolutionProducted[j]) {  
						//if there is a thread which has not generated a new solution
						continue outer;
					}
				}
				index ++;

				boolean isChangePop = false;  //
				ArrayList <Integer> indexToRetain = new ArrayList<Integer>(); //the indexes that will kept in this loop
				for (int j = 0; j < numOfThreads; j ++) {
					if (canNewSolutionAdapted[j]) {
						if (!isChangePop) {  //
							indexToRetain = indexOfSolutionToRetain.get(j);
						}
						else {
							indexToRetain.retainAll(indexOfSolutionToRetain.get(j));
						}
						isChangePop = true;
					}
				}
				
				if (isChangePop) {
					popSize = 0;
					ArrayList <Matrix> f = new ArrayList<Matrix> ();
					ArrayList <Matrix> p = new ArrayList<Matrix> ();
					
					for (int k = 0; k < indexToRetain.size(); k ++) {
						f.add(fitness.get(indexToRetain.get(k)));
						p.add(population.get(indexToRetain.get(k)));
						popSize ++;
					}
					fitness = f;
					population = p;
				}
				
				for (int j = 0; j < numOfThreads; j ++) {
					if (canNewSolutionAdapted[j]){
						for (int k = j + 1; k < numOfThreads; k ++) {
							if (canNewSolutionAdapted[k]) {
								if (dominate_weak(offspringFits[j], offspringFits[k])) {
									canNewSolutionAdapted[k] = false;
								}
								else if (dominate(offspringFits[k], offspringFits[j])) {
									canNewSolutionAdapted[j] = false;
									break;
								}
							}
						}
					}
				}
				
				for (int j = 0; j < numOfThreads; j ++) {
					if (canNewSolutionAdapted[j]) {
						fitness.add(offspringFits[j]);
						population.add(offsprings[j]);
						popSize ++;
					}
				}
				
				offspringChosen = population.get(Math.abs(rand.nextInt() % population.size()));
				
				for (int j = 0; j < numOfThreads; j ++) {
					canNewSolutionAdapted[j] = false;
					indexOfSolutionToRetain.set(j, new ArrayList <Integer> () ) ;
					offsprings [j] = null;
					offspringFits [j] = null;
					isNewSolutionProducted[j] = false;
				}
				
				if (index % stepToRecord == 0) {
					System.out.println(index * numOfThreads * 100.0 / T + "% : " + index * numOfThreads + " / " + T);
					double temp_err = - 1;
					for (int j = 0; j < fitness.size(); j ++) {
						if (temp_err == -1 && fitness.get(j).getAsDouble(0, 1) <= k) {
							temp_err = fitness.get(j).getAsDouble(0,0);
						}
						else if (temp_err > fitness.get(j).getAsDouble(0,0) && fitness.get(j).getAsDouble(0, 1) <= k) {
							temp_err = fitness.get(j).getAsDouble(0,0);
						}
					}
					
					System.out.println("error : " + temp_err);
				}
			}

			executor.shutdown();
			while(!executor.isTerminated()) {
				
			}
			
			Matrix result = null;
			for (int i = 0; i < fitness.size(); i ++) {
				if(fitness.get(i).getAsDouble(0,1) <= k) {
					if (result == null) {
						result = fitness.get(i);
					}
					else if (fitness.get(i).getAsDouble(0, 0) < result.getAsDouble(0, 0) ) {
						result = fitness.get(i);
					}
				}
				
			}
			
			t = System.currentTimeMillis() - t;
			System.out.println("time : " + t / 1000.0);
			System.out.println("error : " + result.getAsDouble(0, 0));
			
			return result;

		}
		
		static class ProductSolution implements Runnable {
			private int num ; //thread id
			private int loop; 
			
			public ProductSolution(int num, int loop) {
				this.num = num;
				this.loop = loop;
			}
			public Random rand = new Random();
			public ArrayList <Integer>find_position(Matrix vector){
				//find the positions of non-zeros
				ArrayList<Integer> r = new ArrayList<Integer>();
				
				long n = vector.getColumnCount();
				for (int j = 0; j < n; j ++) {
					if (vector.getAsInt(0, j) == 1) {
						r.add(j);
					}
				}
				
				return r;
			}
			public Matrix randsrc(int m, int n){
				//a matrix of m * n
				// each element set to be 1 with prob 1/n, and 0 with prob 1-1/n
				double flag = 1.0 / n;
				double [][] d = new double [m][n];
				for (int i = 0; i < m; i ++) {
					for (int j = 0; j < n; j ++){
						if (rand.nextDouble() < flag) {
							d[i][j] = 1;
						}
					}
				}
				Matrix r = DenseMatrix.Factory.importFromArray(d);
				return r;
			}
			public boolean dominate(Matrix s1, Matrix s2) {
				if ( (s1.getAsDouble(0, 0) < s2.getAsDouble(0, 0) && s1.getAsDouble(0, 1) <= s2.getAsDouble(0, 1)) || 
						(s1.getAsDouble(0, 0) <= s2.getAsDouble(0, 0) && s1.getAsDouble(0, 1) < s2.getAsDouble(0, 1))) {
					return true;
				}
				return false;
			}
			public boolean dominate_weak(Matrix s1, Matrix s2) {
				if (s1.getAsDouble(0, 0) <= s2.getAsDouble(0, 0) && s1.getAsDouble(0, 1) <= s2.getAsDouble(0, 1) ){
					return true;
				}
				return false;
			}
			public double sum_vector(Matrix v) {
				//sum of elements
				long n = v.getColumnCount();
				double r = 0;
				for (int i = 0; i < n; i ++) {
					r += v.getAsDouble(i, 0);
				}
				return r;
			}
			public void run() {
				int index = 0;
				Matrix cloneX = X;
				Matrix cloney = y;
				long clone_n = n;
				long clone_m = m;
				while (index < loop){	
					if (isNewSolutionProducted[num]) { 
						//if the new solution is generated, then the thread will wait until the main thread updates the population(and isNewSolutionProducted[num] will be false)
						continue;
					}
					index ++;
					Matrix d_offspring = randsrc(1, (int)clone_n);
					
					Matrix offspring = (offspringChosen.minus(d_offspring)).abs(Ret.NEW);
					
					Matrix offspringFit = DenseMatrix.Factory.zeros(1, 2);
					offspringFit.setAsDouble(sum_vector(offspring), 0, 1);
					
					
					if (offspringFit.getAsDouble(0, 1) == 0 || offspringFit.getAsDouble(0, 1) >= 2 * k) {
						offspringFit.setAsDouble(Double.MAX_VALUE, 0, 0);
					}
					else {
						ArrayList <Integer> pos = find_position(offspring);
						Matrix X_pos = cloneX.selectColumns(Ret.NEW, pos);
						
//						Matrix _a = X_pos.transpose().mtimes(X_pos);
//						Matrix _c = X_pos.transpose().mtimes(cloney);
//						Matrix coef = (_a.pinv()).mtimes(_c);
//						Matrix res = cloney.minus(X_pos.mtimes(coef));
//						Matrix err = res.transpose().mtimes(res).times(1.0 / clone_m);
						
						double err = f(X_pos, cloney);
						
						offspringFit.setAsDouble(err, 0, 0);
					}
										
					boolean is_new_solution = true; //if the new solution can be accepted
										
					for (Matrix fit : fitness) {
						if (dominate(fit, offspringFit)) {
							is_new_solution = false;
							break;
						}
					}
									
					if (is_new_solution) {
						canNewSolutionAdapted[num] = true; 
						offspringFits[num] = offspringFit;
						offsprings[num] = offspring;
						
						for (int i = 0; i < fitness.size(); i ++) { //
							if (!dominate_weak(offspringFit, fitness.get(i))) {
								indexOfSolutionToRetain.get(num).add(i);
							}
						}
					}
					else {}				
					isNewSolutionProducted[num] = true;	
				}
				System.out.println("thread-" + num + " is terminated");
			}
		}
		
		public static double f (Matrix X, Matrix y){
			//mean square error
			//you can change this function to your objective function
			Matrix _a = X.transpose().mtimes(X);
			Matrix _c = X.transpose().mtimes(y);
			Matrix coef = (_a.pinv()).mtimes(_c);
			Matrix res = y.minus(X.mtimes(coef));
			Matrix err = res.transpose().mtimes(res).times(1.0 / m);
			return err.getAsDouble(0, 0);
		}
		
		public static void main(String [] args) throws IOException {
			//example : sparse mean square error
			//if you want to change the objective function, you can go in to the PPOSS.java and change the f in line 338.
		
			System.out.println("the data we use is normalized ...");
			// before you change data path below, you should change the value of m,n
			m = 506; //rows
			n = 13; //cols
			k = 8;
			// T is the thoretical upper bound, you'd better keep T not changed.
			T = Math.round(2 * Math.exp(1) * k * k * n);
			
			String split = " ";
			X = getData("./normal_housing_X.txt", split, (int)m, (int)n);
			y = getData("./normal_housing_Y.txt", split, (int)m, (int)n);
			
			int core_num = 2;
			//result is matrix of Pareto vectors
			Matrix result = POSS_Multi_Thread(core_num);
			
			
		}


		public static boolean dominate(Matrix s1, Matrix s2) {
			if ( (s1.getAsDouble(0, 0) < s2.getAsDouble(0, 0) && s1.getAsDouble(0, 1) <= s2.getAsDouble(0, 1)) || 
					(s1.getAsDouble(0, 0) <= s2.getAsDouble(0, 0) && s1.getAsDouble(0, 1) < s2.getAsDouble(0, 1))) {
				return true;
			}
			return false;
		}
		public static boolean dominate_weak(Matrix s1, Matrix s2) {
			if (s1.getAsDouble(0, 0) <= s2.getAsDouble(0, 0) && s1.getAsDouble(0, 1) <= s2.getAsDouble(0, 1) ){
				return true;
			}
			return false;
		}
		
		public static Matrix getData(String filename, String split, int row, int col) throws IOException { //split ·Ö¸î·û
			File file = new File (filename); 
			FileInputStream in=new FileInputStream (file); 
			InputStreamReader in_reader=new InputStreamReader (in,"UTF-8"); 
			BufferedReader buf_reader=new BufferedReader(in_reader); 
			System.out.println(filename);
			System.out.println(row + " " + col);
			String str;
			Matrix result = DenseMatrix.Factory.zeros(row, col);
			int r = 0;
			int c = 0;
			while((str = buf_reader.readLine()) != null) {
				String [] x_str = str.split(split);
				c = 0;
				for (int i = 0; i < x_str.length; i ++) {
					if (!x_str[i].isEmpty())
						result.setAsDouble(Double.parseDouble(x_str[i]), r, c ++);
				}
				r ++;
			}
			
			
			buf_reader.close();
			in_reader.close();
			return result;
		}
		
		public static Matrix normalization (Matrix D) {
			long m = D.getRowCount();
			long n = D.getColumnCount();
			
			Matrix mean = D.mean(Ret.NEW, 0, true);
			Matrix std = D.std(Ret.NEW, 0, true, false);
			
			ArrayList <Integer>nan = new ArrayList<Integer>();
			
			outer : for  (int j = 0; j < n; j ++) {
				for (int i = 0; i < m; i ++) {
					if (std.getAsDouble(0, j) == 0) {
						nan.add(j);
						continue outer;  
					}
					D.setAsDouble((D.getAsDouble(i, j) - mean.getAsDouble(0, j)) / std.getAsDouble(0, j) , i, j);
				}
			}
			mean = null;
			std = null;
			Matrix result = D.deleteColumns(Ret.LINK, nan);
			System.out.println("[" + result.getRowCount() + "," + result.getColumnCount() + "]");
			return result;
		}
		public static double sum_vector(Matrix v) {
			//sum of all elements
			long n = v.getColumnCount();
			double r = 0;
			for (int i = 0; i < n; i ++) {
				r += v.getAsDouble(i, 0);
			}
			return r;
		}

	}

